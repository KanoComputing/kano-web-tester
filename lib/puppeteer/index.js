/* eslint-disable global-require */
const puppeteer = require('puppeteer');
const ServeRunner = require('../serve/index');
const { EventEmitter } = require('events');
const { parse } = require('flatted/cjs');

const DEFAULTS = {
    headless: true,
    slowMo: 100,
    timeout: 10000,
};

class PuppeteerRunner extends ServeRunner {
    constructor(opts) {
        super(opts);
        this.port = 0;
        this.options = Object.assign({}, DEFAULTS, opts.puppeteer || {});
        this.options.coverage = opts.coverage || false;
    }
    /**
     * Registers the methods onto the page to deal with test coverage
     * @param {Page} page The puppeteer page
     */
    handleCoverage(page) {
        return new Promise(async (resolve) => {
            // Expose the `sendCoverage` function to the browser process.
            // This function will be called with the coverage data once the tests finish
            await page.exposeFunction('__webTester_sendCoverage', (data) => {
                const IstanbulOutput = require('./istanbul');
                const output = new IstanbulOutput(data);
                // This is generated by the parent serve runner.
                // The server runner will build this cache as files are requested by the browser
                if (this.sourceMapCache) {
                    output.applySourceMap(this.sourceMapCache);
                }
                output.addAll(this.options.reporter);
                output.write();
                resolve();
            });
        });
    }
    /**
     * Registers methods on the page to handle a mocha test run
     * @param {Page} page Pupppeteer page
     */
    handleTest(page) {
        return new Promise(async (resolve) => {
            const emitter = new EventEmitter();
            let reporter;
            // Handle the different reporters. Only two here
            if (this.options.reporter === 'xunit') {
                // eslint-disable-next-line global-require
                const XUnit = require('./reporters/xunit');
                reporter = new XUnit(emitter);
            } else {
                // eslint-disable-next-line global-require
                const Spec = require('./reporters/spec');
                reporter = new Spec(emitter);
            }
            // A reporter will call this when it wrapped everything up
            reporter.onDidFinish(() => {
                reporter.dispose();
                resolve();
            });
            // Expose the onMochaEvent function to the browser process.
            // It will be used to proxy every single mocha event back here.
            // A custom `results` event is also sent when the browser gathered all the result data
            await page.exposeFunction('__webTester_onMochaEvent', (data) => {
                const args = data.args.map(arg => parse(arg));
                // Proxy the event in the emitter
                emitter.emit(data.name, ...args);
            });
        });
    }
    run() {
        return super.run(false)
            .then((server) => {
                const { port } = server.address();
                // Launch the browser
                return puppeteer.launch(this.options)
                    // Create a new page
                    .then(browser => browser.newPage())
                    .then(async (page) => {
                        let p = null;
                        // The main process/browser process interactions differs whether
                        // we run a test or do a coverage
                        if (this.options.coverage) {
                            p = this.handleCoverage(page);
                        } else {
                            p = this.handleTest(page);
                        }
                        // Navigate to the generated port
                        await page.goto(`http://localhost:${port}`);
                        return p;
                    });
            });
    }
}

module.exports = PuppeteerRunner;
